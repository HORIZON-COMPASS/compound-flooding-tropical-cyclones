#%%
import os
from os.path import join
from pathlib import Path
import xarray as xr
import numpy as np
import geopandas as gpd

from hydromt_sfincs import SfincsModel, utils
from hydromt import DataCatalog

import matplotlib.ticker as mticker
import matplotlib.pyplot as plt
import matplotlib.dates as mdates
import matplotlib.colors as mcolors
from matplotlib.colors import PowerNorm
from matplotlib.colors import BoundaryNorm
import matplotlib.gridspec as gridspec
from matplotlib.cm import ScalarMappable

from pyproj import Transformer
import cartopy.crs as ccrs
import cartopy.feature as cfeature
import contextily as ctx
from cartopy.mpl.gridliner import LONGITUDE_FORMATTER, LATITUDE_FORMATTER
from shapely.geometry import box
from rasterio.features import shapes
from shapely.geometry import shape

import warnings
warnings.filterwarnings('ignore')

import platform
prefix = "p:/" if platform.system() == "Windows" else "/p/"

def lat_formatter(x, pos):
    direction = 'N' if x >= 0 else 'S'
    return f"{abs(x):.1f}°{direction}"
def lon_formatter(x, pos):
    direction = 'E' if x >= 0 else 'W'
    return f"{abs(x):.1f}°{direction}"

def custom_formatter(value, pos=None):
    return f"{value:.1f}°"

#%%
# define model and data catalog file paths
factual_model_dir = os.path.join(prefix,"11210471-001-compass","03_Runs","sofala","Idai","sfincs","event_tp_era5_hourly_zarr_CF0_GTSMv41_CF0_era5_hourly_spw_IBTrACS_CF0")

datacat = [
        '../../Workflows/03_data_catalogs/datacatalog_general.yml',
        '../../Workflows/03_data_catalogs/datacatalog_SFINCS_obspoints.yml',
        '../../Workflows/03_data_catalogs/datacatalog_SFINCS_coastal_coupling.yml',
        '../../Workflows/03_data_catalogs/datacatalog_CF_forcing.yml'
        ]

data_catalog = DataCatalog(data_libs = datacat)

#%%
# Load in model, model region, and buffer model region
mod = SfincsModel(factual_model_dir, data_libs=datacat, mode="r")

hisfile = os.path.join(factual_model_dir,"sfincs_his.nc")
ds_his = xr.open_dataset(hisfile, engine='netcdf4')

model_region_gdf = gpd.read_file(join(
    prefix, "11210471-001-compass", "03_Runs", "sofala", "Idai", "sfincs", 
    "event_tp_era5_hourly_zarr_CF0_GTSMv41_CF0_era5_hourly_spw_IBTrACS_CF0", "gis", "region.geojson"
)).to_crs("EPSG:4326") 

buffered_region_gdf = gpd.read_file(join(
    prefix, "11210471-001-compass", "01_Data", "sofala_geoms", 
    "sfincs_region_buffered_5km_exclNorthernBasin.shp")).to_crs("EPSG:32736") 

buffered_region_gdf_wsg = gpd.read_file(join(
    prefix, "11210471-001-compass", "01_Data", "sofala_geoms", 
    "sfincs_region_buffered_5km_exclNorthernBasin.shp")).to_crs("EPSG:4326") 

#%%
# we set a threshold to mask minimum flood depth
hmin = 0.05

# compute the maximum over all time steps
da_zsmax = mod.results["zsmax"].max(dim="timemax")
     
# downscale the floodmap
depfile  = join(factual_model_dir, "subgrid", "dep_subgrid.tif")
da_dep   = mod.data_catalog.get_rasterdataset(depfile)

da_hmax = utils.downscale_floodmap(
      zsmax=da_zsmax,
      dep=da_dep,
      hmin=hmin,
      )
    
# GSWO dataset to mask permanent water by first geprojecting it to the subgrid of hmax
sfincs_region = mod.region
projection    = mod.crs.to_epsg()
gwso_region   = data_catalog.get_rasterdataset("gswo", geom=sfincs_region, buffer=1000)
gswo_mask     = gwso_region.raster.reproject_like(da_hmax, method="max")
# permanent water where water occurence > 5%
da_hmax_masked = da_hmax.where(gswo_mask <= 5)

# Add the name attribute for identification
mod.results['hmax'] = da_hmax
mod.results['hmax_masked'] = da_hmax_masked

da_hmax_masked_buffered = da_hmax_masked.rio.clip(buffered_region_gdf.geometry)
mod.results['hmax_masked_buffered'] = da_hmax_masked_buffered

# Make own background shape
# 1 = valid (non-permanent water), 0 = permanent water
valid_mask = (gswo_mask <= 5).astype("uint8").squeeze()

# Extract shapes
shapes_gen = shapes(valid_mask.values, transform=valid_mask.rio.transform())
valid_polygons = [shape(geom) for geom, val in shapes_gen if val == 1]
gdf_valid = gpd.GeoDataFrame(geometry=valid_polygons, crs=gswo_mask.rio.crs)
gdf_valid = gdf_valid.to_crs(model_region_gdf.crs)

del da_hmax, da_zsmax, da_dep  # Clean up to free memory


#%%
fig, ax = plt.subplots(nrows=1,
                       ncols=1,
                       figsize=(8,8),
                       dpi=300,
                       constrained_layout=True,
                       subplot_kw={"projection": ccrs.epsg(projection)})

fig.suptitle("Factual Max Flood Depth", fontsize=11)

# Plot hmax masked
hmax = mod.results['hmax_masked_buffered']

vmin = float(hmax.min())
vmax = float(hmax.max())

im = hmax.plot.pcolormesh(
    ax=ax, cmap="Blues", vmin=vmin, vmax=3, add_colorbar=False
)

# Add basemap
# ctx.add_basemap(ax, source=ctx.providers.Esri.WorldImagery,
#                 zoom=10,
#                 crs=mod.results['hmax_masked'].rio.crs,
#                 attribution=False)
# ax.add_feature(cfeature.LAND.with_scale('10m'), facecolor='lightgrey', zorder=0)
gdf_valid.plot(ax=ax, color='lightgrey', transform=ccrs.PlateCarree(), zorder=0)

# Add model region
buffered_region_gdf_wsg.boundary.plot(ax=ax, edgecolor='black', linewidth=0.5, transform=ccrs.PlateCarree())

# Set extent (based on actual lat/lon coordinates)
minx, miny, maxx, maxy = buffered_region_gdf_wsg.bounds.minx.item(), buffered_region_gdf_wsg.bounds.miny.item(), buffered_region_gdf_wsg.bounds.maxx.item(), buffered_region_gdf_wsg.bounds.maxy.item()
ax.set_extent([minx, maxx, miny, maxy], ccrs.PlateCarree())

# Add gridlines and format tick labels
gl = ax.gridlines(draw_labels=True, linewidth=0.5, color='gray', alpha=0.5, linestyle='--')
gl.xlocator = mticker.FixedLocator(np.arange(minx, maxx + 0.1, 0.2))
gl.ylocator = mticker.FixedLocator(np.arange(miny, maxy + 0.1, 0.2))
gl.xformatter = mticker.FuncFormatter(lon_formatter)
gl.yformatter = mticker.FuncFormatter(lat_formatter)
gl.right_labels = False
gl.top_labels = False
gl.xlabel_style = {'size': 11}
gl.ylabel_style = {'size': 11}


# Titles
ax.set_title(f"", fontsize=16)

# Add shared colorbar with larger size and labels
cbar = fig.colorbar(im, ax=ax, orientation="vertical", 
                    fraction=0.035, pad=0.05)
cbar.set_label('Flood depth (m)', labelpad=5, fontsize=9)
cbar.ax.tick_params(labelsize=8)
    
fig.savefig("../figures/factual_hmax_masked.png", bbox_inches='tight', dpi=300)
plt.show()

#%%
### PLOT TIMESERIES OUTPUT POINTS
fig, ax = plt.subplots(3,1,figsize=(8,8), sharex=True, dpi=300)
ax[0].plot(ds_his.time,ds_his['point_zs'].isel(stations=8),color='r', label=f'Station 5')
ax[0].plot(mod.forcing['bzs'].time, mod.forcing['bzs'].sel(index=40), label=f'Station 40')

ax[1].plot(mod.forcing['dis'].time, mod.forcing['dis'].sel(index=1), label=f'Gauge 1')
ax[1].plot(mod.forcing['dis'].time, mod.forcing['dis'].sel(index=2), label=f'Gauge 2')

ax[2].step(mod.forcing['precip_2d'].time, mod.forcing['precip_2d'].mean(dim=["x", "y"]), where='post')

for a in ax:
    a.set_xlim(ds_his.time.min(), ds_his.time.max())
    a.legend(fontsize=9, loc="upper right") 
    a.tick_params(axis='both', labelsize=10)
    a.grid(True, which='major', linestyle='--', linewidth=0.5, alpha=0.7)

# ax.set_title(f"Timeseries of water levels \n Location: {ds_his['station_id'].isel(stations=5).values}")
ax[0].set_ylabel("Water level height \n [m]")
ax[1].set_ylabel("Discharge \n [m3/s]")
ax[2].set_ylabel("Mean precipitation \n [mm/h] [m]")
ax[2].xaxis.set_major_formatter(mdates.DateFormatter('%d'))
ax[2].set_xlabel("Day in March 2019")
# fig.savefig(os.path.join(os.path.abspath(os.path.dirname(outfile)),f'sfincs_output_TS_loc_{loc_id}.png'))
fig.show()


#%%
gauges_list   = [1,2]
stations_list = [5, 40]

fig = plt.figure(figsize=(15, 6), dpi=300, constrained_layout=True)

projection = mod.crs.to_epsg()
colors = plt.get_cmap('tab10').colors  # Tuple of 10 colors

gs = gridspec.GridSpec(nrows=3, ncols=2, figure=fig,
                       width_ratios=[2, 1],  # Left col 3x wider than right col
                       height_ratios=[1, 1, 1],  # Three rows on right all equal height
                       wspace=0.05, hspace=0.05)

ax_map = fig.add_subplot(gs[:, 0], projection=ccrs.epsg(projection))

# Plot hmax masked
im = mod.results['hmax_masked'].plot.pcolormesh(
    ax=ax_map, cmap="Blues", vmin=0, vmax=5.0, add_colorbar=False
)

ax_map.set_title("Factual Max Flood Depth", fontsize=14)

# Add model region
model_region_gdf.boundary.plot(ax=ax_map, edgecolor='black', linewidth=0.5, transform=ccrs.PlateCarree())

# Add background and extent
ax_map.add_feature(cfeature.LAND.with_scale('10m'), facecolor='lightgrey', zorder=0)

# Set extent (based on actual lat/lon coordinates)
minx, miny, maxx, maxy = model_region_gdf.bounds.minx.item(), model_region_gdf.bounds.miny.item(), model_region_gdf.bounds.maxx.item(), model_region_gdf.bounds.maxy.item()
ax_map.set_extent([minx, maxx, miny, maxy], ccrs.PlateCarree())

# Gridlines
gl = ax_map.gridlines(draw_labels=True, linewidth=0.5, color='gray', alpha=0.5, linestyle='--')
gl.xlocator = mticker.FixedLocator(np.arange(minx, maxx + 0.1, 0.2))
gl.ylocator = mticker.FixedLocator(np.arange(miny, maxy + 0.1, 0.2))
gl.xformatter = mticker.FuncFormatter(lon_formatter)
gl.yformatter = mticker.FuncFormatter(lat_formatter)
gl.right_labels = False
gl.top_labels = False
gl.xlabel_style = {'size': 11}
gl.ylabel_style = {'size': 11}

# Colorbar for map
cbar = fig.colorbar(im, ax=ax_map, orientation="vertical", fraction=0.035, pad=0.01)
cbar.set_label('Flood depth (m)', rotation=270, labelpad=10, fontsize=10)
cbar.ax.tick_params(labelsize=9)

# RIGHT: three stacked time series subplots
ax0 = fig.add_subplot(gs[0, 1])
ax1 = fig.add_subplot(gs[1, 1], sharex=ax0)
ax2 = fig.add_subplot(gs[2, 1], sharex=ax0)

# Plotting timeseries
ax0.plot(ds_his.time, ds_his['point_zs'].isel(stations=stations_list[0]), color=colors[4], label=f'S{stations_list[0]}')
ax0.plot(mod.forcing['bzs'].time, mod.forcing['bzs'].sel(index=stations_list[1]), color=colors[1], label=f'S{stations_list[1]}')
ax0.set_ylabel("Water level height \n [m]", fontsize=10)
ax0.legend(fontsize=8, loc="upper right")
ax0.grid(True, linestyle='--', alpha=0.6)
ax0.tick_params(labelsize=9)
ax0.set_xlim(ds_his.time.min(), ds_his.time.max())
ax0.set_title("Factual Time Series", fontsize=14)


ax1.plot(mod.forcing['dis'].time, mod.forcing['dis'].sel(index=gauges_list[0]), color=colors[2], label=f'G{gauges_list[0]}')
ax1.plot(mod.forcing['dis'].time, mod.forcing['dis'].sel(index=gauges_list[1]), color=colors[3], label=f'G{gauges_list[1]}')
ax1.set_ylabel("Discharge \n [m³/s]", fontsize=10)
ax1.legend(fontsize=8, loc="upper right")
ax1.grid(True, linestyle='--', alpha=0.6)
ax1.tick_params(labelsize=9)
ax1.set_xlim(ds_his.time.min(), ds_his.time.max())

ax2.step(mod.forcing['precip_2d'].time, mod.forcing['precip_2d'].mean(dim=["x", "y"]), where='post', color=colors[0])
ax2.set_ylabel("Mean precipitation \n [mm/h]", fontsize=10)
ax2.set_xlabel("Day in March 2019")
ax2.xaxis.set_major_formatter(mdates.DateFormatter('%d'))
ax2.grid(True, linestyle='--', alpha=0.6)
ax2.tick_params(labelsize=9)
ax2.set_xlim(ds_his.time.min(), ds_his.time.max())

# Plot station and Gauge points on the flood map and annotate
ax_map.scatter(ds_his['point_zs'].isel(stations=stations_list[0]).point_x.values, ds_his['point_zs'].isel(stations=stations_list[0]).point_y.values, color=colors[4], s=30, edgecolor='k', zorder=5, transform=ccrs.epsg(projection), label=f'Station {stations_list[0]}')
ax_map.scatter(mod.forcing['bzs'].sel(index=stations_list[1]).geometry.item().x, mod.forcing['bzs'].sel(index=stations_list[1]).geometry.item().y, color=colors[1], s=30, edgecolor='k', zorder=5, transform=ccrs.epsg(projection), label=f'Station {stations_list[1]}')

ax_map.scatter(mod.forcing['dis'].sel(index=gauges_list[0]).geometry.item().x, mod.forcing['dis'].sel(index=gauges_list[0]).geometry.item().y, color=colors[2], s=30, edgecolor='k', zorder=5, transform=ccrs.epsg(projection), label=f'Gauge {gauges_list[0]}')
ax_map.scatter(mod.forcing['dis'].sel(index=gauges_list[1]).geometry.item().x, mod.forcing['dis'].sel(index=gauges_list[1]).geometry.item().y, color=colors[3], s=30, edgecolor='k', zorder=5, transform=ccrs.epsg(projection), label=f'Gauge {gauges_list[1]}')

offset = 2000  # Adjust offset depending on map scale (in map projection units)
ax_map.annotate(f'S{stations_list[0]}', xy=(ds_his['point_zs'].isel(stations=stations_list[0]).point_x.values, ds_his['point_zs'].isel(stations=stations_list[0]).point_y.values),
                xytext=(ds_his['point_zs'].isel(stations=stations_list[0]).point_x.values + 2000, ds_his['point_zs'].isel(stations=stations_list[0]).point_y.values - 4000),
                transform=ccrs.epsg(projection),
                fontsize=9, color=colors[4], fontweight='bold',
                bbox=dict(boxstyle="round,pad=0.3", fc="white", ec="black", lw=0.5, alpha=0.8)
)
ax_map.annotate(f'S{stations_list[1]}', xy=(mod.forcing['bzs'].sel(index=stations_list[1]).geometry.item().x, mod.forcing['bzs'].sel(index=stations_list[1]).geometry.item().y),
                xytext=(mod.forcing['bzs'].sel(index=stations_list[1]).geometry.item().x + 2000, mod.forcing['bzs'].sel(index=stations_list[1]).geometry.item().y - 4000),
                transform=ccrs.epsg(projection),
                fontsize=9, color=colors[1], fontweight='bold',
                bbox=dict(boxstyle="round,pad=0.3", fc="white", ec="black", lw=0.5, alpha=0.8)
)
ax_map.annotate(f'G{gauges_list[0]}', xy=(mod.forcing['dis'].sel(index=gauges_list[0]).geometry.item().x, mod.forcing['dis'].sel(index=gauges_list[0]).geometry.item().y),
                xytext=(mod.forcing['dis'].sel(index=gauges_list[0]).geometry.item().x - 6000, mod.forcing['dis'].sel(index=gauges_list[0]).geometry.item().y - 4000),
                transform=ccrs.epsg(projection),
                fontsize=9, color=colors[2], fontweight='bold',
                bbox=dict(boxstyle="round,pad=0.3", fc="white", ec="black", lw=0.5, alpha=0.8)
)
ax_map.annotate(f'G{gauges_list[1]}', xy=(mod.forcing['dis'].sel(index=gauges_list[1]).geometry.item().x, mod.forcing['dis'].sel(index=gauges_list[1]).geometry.item().y),
                xytext=(mod.forcing['dis'].sel(index=gauges_list[1]).geometry.item().x + 2000, mod.forcing['dis'].sel(index=gauges_list[1]).geometry.item().y),
                transform=ccrs.epsg(projection),
                fontsize=9, color=colors[3], fontweight='bold',
                bbox=dict(boxstyle="round,pad=0.3", fc="white", ec="black", lw=0.5, alpha=0.8)
)

plt.show()





#%% ############################################
# ========== Factual damage plotting ===========
################################################
# Base paths - update these as needed
BASE_RUN_PATH = Path(os.path.join(prefix,"11210471-001-compass","03_Runs","sofala"))
OUTPUT_DIR = Path("../figures")

# ===== FILE PATHS =====
# buildings with no damage have already been masked out
file_cf0 = BASE_RUN_PATH / "Idai" / "fiat" / "event_tp_era5_hourly_zarr_CF0_GTSMv41_CF0_era5_hourly_spw_IBTrACS_CF0" / "output" / "output_relative_damage.fgb"

model_region_gdf = gpd.read_file(join(prefix, "11210471-001-compass", "03_Runs", "sofala", "Idai", "sfincs", 
                                      "event_tp_era5_hourly_zarr_CF0_GTSMv41_CF0_era5_hourly_spw_IBTrACS_CF0", 
                                      "gis", "region.geojson")).to_crs("EPSG:4326") 

# Create output directory if it doesn't exist
OUTPUT_DIR.mkdir(parents=True, exist_ok=True)

# ===== LOAD DAMAGE DATA =====
print("Loading damage data files...")
print(f"Loading CF0: {file_cf0}")

# Read the geodataframes
gdf_cf0 = gpd.read_file(file_cf0)

#%%
# ===== EXTRACT COORDINATES =====
print("Extracting coordinates from building centroids...")
# Extract x, y coordinates from geometry centroids (for polygon buildings)
gdf_cf0['centroid'] = gdf_cf0.geometry.centroid
gdf_cf0['x'] = gdf_cf0['centroid'].x
gdf_cf0['y'] = gdf_cf0['centroid'].y

gdf_cf0 = gdf_cf0[['object_id', 'x', 'y', 'total_damage', 'max_damage_total']]

# Remove buildings with no coordinates
gdf_cf0 = gdf_cf0.dropna(subset=['x', 'y'])

print(gdf_cf0[['object_id', 'x', 'y', 'total_damage', 'max_damage_total']].head())

#%%
# ===== STATISTICS =====
print(f"\nDamage Statistics for Idai (total_damage):")
cf0_damage = gdf_cf0['total_damage']

print(f"CF0 max damage: ${cf0_damage.max():.0f}")
print(f"CF0 mean damage: ${cf0_damage.mean():.0f}")
print(f"CF0 total damage: ${cf0_damage.sum():.0f}")


#%%
# === PLOTTING ===
print("Creating factual damage plot...")

# Coordinate system: PlateCarree = lat/lon
crs = ccrs.PlateCarree()

# Create damage plotting settings
max_total = cf0_damage.quantile(0.9)
boundaries = np.linspace(0, max_total, 11)
damage_norm = BoundaryNorm(boundaries, ncolors=256, clip=True)
damage_cmap = plt.get_cmap('Reds')
damage_label = 'Total Damage [USD]'

fig, axes = plt.subplots(1, 1, figsize=(8, 8), subplot_kw={'projection': crs})

# Plot settings
point_size = 10
alpha = 0.8

# Convert to GeoDataFrame if not already
gdf_cf0_crs = gpd.GeoDataFrame(gdf_cf0,
                               geometry=gpd.points_from_xy(gdf_cf0["x"], gdf_cf0["y"]),
                               crs="EPSG:32736"  # or match whatever CRS your data is in
                               )

# Ensure same CRS
gdf_damage = gdf_cf0_crs.to_crs(crs)

# Add model region
model_region_gdf.boundary.plot(ax=axes, edgecolor='black', linewidth=0.5, transform=crs)

# Add background and extent
axes.add_feature(cfeature.LAND.with_scale('10m'), facecolor='lightgrey', zorder=0)

# Plot damage points
scatter1 = axes.scatter(
    gdf_damage.geometry.x, gdf_damage.geometry.y,
    c=gdf_damage['total_damage'],
    cmap=damage_cmap, norm=damage_norm,
    s=point_size, alpha=alpha,
    transform=crs
)

# Set extent (based on actual lat/lon coordinates)
minx, miny, maxx, maxy = model_region_gdf.bounds.minx.item(), model_region_gdf.bounds.miny.item(), model_region_gdf.bounds.maxx.item(), model_region_gdf.bounds.maxy.item()
axes.set_extent([minx, maxx, miny, maxy], crs)

# Gridlines
gl = axes.gridlines(draw_labels=True, linewidth=0.5, color='gray', alpha=0.5, linestyle='--')
gl.xlocator = mticker.FixedLocator(np.arange(minx, maxx + 0.1, 0.2))
gl.ylocator = mticker.FixedLocator(np.arange(miny, maxy + 0.1, 0.2))
gl.xformatter = mticker.FuncFormatter(lon_formatter)
gl.yformatter = mticker.FuncFormatter(lat_formatter)
gl.right_labels = False
gl.top_labels = False
gl.xlabel_style = {'size': 11}
gl.ylabel_style = {'size': 11}

# Add colorbar
cbar1 = plt.colorbar(scatter1, ax=axes, shrink=0.8, pad=0.06)
cbar1.set_label(damage_label, fontsize=10)

# Titles and save
plt.tight_layout()
plt.suptitle(f'Factual Total Damage', fontsize=16, y=0.96)

output_file_main = OUTPUT_DIR / f'damage_idai_total_damage.png'
# plt.savefig(output_file_main, dpi=300, bbox_inches='tight')
plt.show()



# %% ##############################################################
# ============= Spatially aggregate damage damage  ================
###################################################################
# clip permanent water shapes to model region
clipped_region = gpd.overlay(buffered_region_gdf_wsg, gdf_valid, how="intersection")

# Set resolution in degrees or meters (depending on CRS)
cell_size = 0.025  # e.g., in degrees for EPSG:4326

# Bounds
minx, miny, maxx, maxy = clipped_region.total_bounds
cols = np.arange(minx, maxx, cell_size)
rows = np.arange(miny, maxy, cell_size)

# Build grid cells
grid_cells = [box(x, y, x + cell_size, y + cell_size) for x in cols for y in rows]
gdf_grid = gpd.GeoDataFrame(geometry=grid_cells, crs=clipped_region.crs)

# Clip again to final shape
gdf_grid_masked = gpd.overlay(gdf_grid, clipped_region, how='intersection')

# %%  
# Spatial join: assign grid cell index to each point
joined = gpd.sjoin(gdf_damage, gdf_grid_masked, how="left", predicate="within")

# Aggregate damage per grid cell
agg_tot_damage = joined.groupby(joined.index_right)["total_damage"].sum()
agg_max_damage = joined.groupby(joined.index_right)["max_damage_total"].sum()

# Assign damage to grid GeoDataFrame
gdf_grid_masked["total_damage"]     = agg_tot_damage
gdf_grid_masked["max_damage_total"] = agg_max_damage
gdf_grid_masked["total_damage"]     = gdf_grid_masked["total_damage"].fillna(0)
gdf_grid_masked["max_damage_total"] = gdf_grid_masked["max_damage_total"].fillna(0)

# Relative percentual damage per grid
gdf_grid_masked['relative_aggr_damage'] = (agg_tot_damage / agg_max_damage) * 100 # %
gdf_grid_masked["relative_aggr_damage"] = gdf_grid_masked["relative_aggr_damage"].fillna(0)




# %% ##############################################################
# ======= Plot the factual aggregated damage and flooding =========
###################################################################
# plot the total_damage, emphazizing lower values
fig, ax = plt.subplots(nrows=1, ncols=1, figsize=(6,6), dpi=300,
                       subplot_kw={"projection": ccrs.PlateCarree()})

# Create colormap normalization
norm = PowerNorm(gamma=0.5, vmin=0, vmax=gdf_grid_masked['total_damage'].max())

# Plot using GeoPandas, but draw to custom ax and return colorbar mappable
plot = gdf_grid_masked.plot(column="total_damage", cmap="Reds", norm=norm, edgecolor="grey",
                            linewidth=0.2, ax=ax, legend=False)

# Add colorbar
sm = ScalarMappable(norm=norm, cmap="Reds")
cbar = fig.colorbar(sm, ax=ax, shrink=0.8, pad=0.06)
cbar.set_label(damage_label, fontsize=10) 


# Add background and extent
ax.add_feature(cfeature.LAND.with_scale('10m'), facecolor='lightgrey', zorder=0)

# Set extent (based on actual lat/lon coordinates)
minx, miny, maxx, maxy = model_region_gdf.bounds.minx.item(), model_region_gdf.bounds.miny.item(), model_region_gdf.bounds.maxx.item(), model_region_gdf.bounds.maxy.item()
ax.set_extent([minx, maxx, miny, maxy], ccrs.PlateCarree())

# Gridlines
gl = ax.gridlines(draw_labels=True, linewidth=0.5, color='gray', alpha=0.5, linestyle='--')
gl.xlocator = mticker.FixedLocator(np.arange(minx, maxx + 0.1, 0.2))
gl.ylocator = mticker.FixedLocator(np.arange(miny, maxy + 0.1, 0.2))
gl.xformatter = mticker.FuncFormatter(lon_formatter)
gl.yformatter = mticker.FuncFormatter(lat_formatter)
gl.right_labels = False
gl.top_labels = False
gl.xlabel_style = {'size': 11}
gl.ylabel_style = {'size': 11}

ax.set_title("Total Aggregated Flood Damage", fontsize=12)
fig.savefig("../figures/total_aggregated_damage.png", bbox_inches='tight', dpi=300)

plt.show()



# %%
# plot the total_damage, emphazizing lower values
fig, ax = plt.subplots(nrows=1, ncols=1, figsize=(6,6), dpi=300,
                       subplot_kw={"projection": ccrs.PlateCarree()})

# Plot using GeoPandas, but draw to custom ax and return colorbar mappable
plot = gdf_grid_masked.plot(column="relative_aggr_damage", cmap="Reds", edgecolor="grey",
                            linewidth=0.2, ax=ax, legend=False, vmin = 0, vmax = 100)

# Add colorbar
sm = ScalarMappable(cmap="Reds", norm=plt.Normalize(vmin=0, vmax=100))
sm.set_array([])  # doesn't need real data; just placeholder for colorbar
cbar = fig.colorbar(sm, ax=ax, shrink=0.8, pad=0.06)
cbar.set_label("Relative Damage [%]", fontsize=10) 

# Add background and extent
ax.add_feature(cfeature.LAND.with_scale('10m'), facecolor='lightgrey', zorder=0)

# Set extent (based on actual lat/lon coordinates)
minx, miny, maxx, maxy = model_region_gdf.bounds.minx.item(), model_region_gdf.bounds.miny.item(), model_region_gdf.bounds.maxx.item(), model_region_gdf.bounds.maxy.item()
ax.set_extent([minx, maxx, miny, maxy], ccrs.PlateCarree())

# Gridlines
gl = ax.gridlines(draw_labels=True, linewidth=0.5, color='gray', alpha=0.5, linestyle='--')
gl.xlocator = mticker.FixedLocator(np.arange(minx, maxx + 0.1, 0.2))
gl.ylocator = mticker.FixedLocator(np.arange(miny, maxy + 0.1, 0.2))
gl.xformatter = mticker.FuncFormatter(lon_formatter)
gl.yformatter = mticker.FuncFormatter(lat_formatter)
gl.right_labels = False
gl.top_labels = False
gl.xlabel_style = {'size': 11}
gl.ylabel_style = {'size': 11}

ax.set_title("Relative damage Map", fontsize=12)
fig.savefig("../figures/relative_aggregated_damage.png", bbox_inches='tight', dpi=300)

plt.show()




# %%
# Plot the damage and flooding as sub panels
fig, axes = plt.subplots(nrows=1, ncols=2, figsize=(15, 6), dpi=300, constrained_layout=True, 
                         subplot_kw={"projection": ccrs.PlateCarree()})

# Plot the flooding
hmax = mod.results['hmax_masked_buffered']
vmin = float(hmax.min())
vmax = float(hmax.max())
im = hmax.plot.pcolormesh(ax=axes[0], cmap="Blues", vmin=vmin, vmax=3, add_colorbar=False)

# Plot the total damage
norm = PowerNorm(gamma=0.5, vmin=0, vmax=gdf_grid_masked['total_damage'].max())
plot = gdf_grid_masked.plot(column="total_damage", cmap="Reds", norm=norm, edgecolor="grey",
                            linewidth=0.2, ax=axes[1], legend=False)

for ax in axes:
    gdf_valid.plot(ax=ax, color='lightgrey', transform=ccrs.PlateCarree(), zorder=0)
    buffered_region_gdf_wsg.boundary.plot(ax=ax, edgecolor='black', linewidth=0.5, transform=ccrs.PlateCarree())

    # Set extent (based on actual lat/lon coordinates)
    minx, miny, maxx, maxy = buffered_region_gdf_wsg.bounds.minx.item(), buffered_region_gdf_wsg.bounds.miny.item(), buffered_region_gdf_wsg.bounds.maxx.item(), buffered_region_gdf_wsg.bounds.maxy.item()
    ax.set_extent([minx, maxx, miny, maxy], ccrs.PlateCarree())

    # Add gridlines and format tick labels
    gl = ax.gridlines(draw_labels=True, linewidth=0.5, color='gray', alpha=0.5, linestyle='--')
    gl.xlocator = mticker.FixedLocator(np.arange(minx, maxx + 0.1, 0.2))
    gl.ylocator = mticker.FixedLocator(np.arange(miny, maxy + 0.1, 0.2))
    gl.xformatter = mticker.FuncFormatter(lon_formatter)
    gl.yformatter = mticker.FuncFormatter(lat_formatter)
    gl.right_labels = False
    gl.top_labels = False
    gl.xlabel_style = {'size': 11}
    gl.ylabel_style = {'size': 11}

# Titles
axes[0].set_title("(a) Flood depth", fontsize=16)
axes[1].set_title("(b) Aggregated Total Damage", fontsize=16)

# ==== Colorbar for Flood Depth ====
cbar1 = fig.colorbar(im, ax=axes[0], orientation="vertical", 
                     shrink=0.8, pad=0.06)
cbar1.set_label("Flood depth (m)", labelpad=5, fontsize=9)
cbar1.ax.tick_params(labelsize=8)

# ==== Colorbar for Damage ====
sm = ScalarMappable(norm=norm, cmap="Reds")
sm.set_array([])  # Required to avoid warning, even if dummy
cbar2 = fig.colorbar(sm, ax=axes[1], orientation="vertical", 
                     shrink=0.8, pad=0.06)
cbar2.set_label(damage_label, labelpad=5, fontsize=9)
cbar2.ax.tick_params(labelsize=8)


fig.savefig("../figures/factual_flooding_and_aggregated_total_damage.png", bbox_inches='tight', dpi=300)
plt.show()

# %%
